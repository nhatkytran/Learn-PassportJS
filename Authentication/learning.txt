---
app.use(express.json());
--> Parse incoming JSON data from HTTP requests

app.use(express.urlencoded({ extended: < Boolean > }));
--> Parse incoming data encoded in the 'application/x-www-form-urlencoded' format \
such as form submission
< Boolean >
--> true --> the parsed data can contain rich objects and arrays
--> false --> the parsed data can only contain string values

--> 'SIGTERM' event allows the server to gracefully shut down in response to \
a termination signal, ensuring that data and resources are not lost or corrupted
---

--- Mongoose v/s MongoDB Driver
Both Mongoose and the MongoDB driver allow for interacting with a MongoDB database \
in a Node.js application. However, Mongoose offers several advantages over the \
MongoDB driver that make it a popular choice for many developers. Here are a few \
reasons why:
--> Simplicity: Mongoose provides an easier way to interact with the database \
by defining models with data validations and custom methods. The MongoDB driver, \
on the other hand, requires the developer to define all the database-level \
validation and business logic from scratch, which can be complex and \
time-consuming
--> Data modeling: Mongoose provides a layer of abstraction over MongoDB that \
makes data modeling and schema definition easier. It allows you to define your \
data models with data types, relationships, and validations, which makes it easier \
to work with your data
--> Data transformation: Mongoose allows you to transform the data before it is \
returned from the database. This feature makes it easy to convert the stored data \
into the format that your application needs without modifying the original data
--> Middleware: Mongoose provides middleware functions that can be executed before \
or after certain events, such as saving or deleting a document from the database. \
These middleware functions can be used to perform additional processing on the data \
or to trigger other events
--> Query building: Mongoose provides a query building API that makes it easy to \
construct complex queries with less code. The MongoDB driver requires the developer \
to write a lot of code to construct complex queries
In summary, while both Mongoose and the MongoDB driver allow for interacting with \
a MongoDB database, Mongoose provides a higher level of abstraction and offers \
features such as data modeling, data transformation, middleware, and query building \
that make database interactions easier and more efficient
---

--> What is PassportJS?

--> Passport Strategy --> A middleware connecting to the bigger PassportJS middleware
--> All about PassportJS is middlewares that integrates within your ExpressJS application \
and handles all the authentication logic using the specific strategy we choose to plug into \
the PassportJS framework
--> PassportJS throw 401 Unauthorized

--> Express Sessions

--> PassoprtJS Local Strategy uses Express Session under the hood

--> npm install express-session
--> npm install connect-mongo

---
const session = require('express-session');
const connectMongo = require('connect-mongo');
const MongoStore = connectMongo(session);
---

--> What is the difference between a session and a cookie?
--> Basically, a session and a cookie are different in the places that their data \
is stored
+ A cookie has its data stored in the browser and the browser is going to attach that \
cookie key value pair to every http request that it does
+ A session on the other hand is going to be stored on the server side (the ExpressJS \
application) --> Express Session is going to store a little bit bigger types of data

--> Store credentials data in Express Session, not in cooke --> Security purpose
--> Session is stored on server side and we can authenticate into the session with a \
secret key

---

--> A session and a cookie are both used to store information that can be retrieved \
by a server, but they work in different ways and have different purposes

--> A session is a way to keep track of user activity on a website during a single visit \
or "session." When a user opens a website, a unique session ID is generated by the server \
and sent to the user's browser in the form of a cookie. This session ID acts like a key \
that allows the server to track the user's actions on the site as they navigate from page \
to page. The server can use this information to personalize the user's experience, \
remember user preferences, and keep track of items in a shopping cart. When the user \
closes their browser or the session expires, the session data is deleted

--> A cookie, on the other hand, is a small text file that is stored on a user's computer \
by a website. Cookies are typically used to store information about site preferences, \
login information, and other details that help personalize the user's experience. \
Unlike a session, a cookie can persist even after the user closes their browser, \
allowing the website to recognize the user on subsequent visits. Cookies can also be used \
to track user behavior across multiple websites for advertising or analytics purposes

--> In summary, a session is used to keep track of a user's activity within a single \
visit to a website, while a cookie is used to store information that persists across \
multiple visits

---

--> Establish a new session --> Make a http request to the application --> session middleware \
is going to kind of fire and create a session --> create a SessionID stored in browser's cookie


---

--> What is the difference between Express Session and Json Web Tokens?

--> Express Session --> Stateful --> Require storing session data on a server
--> Json Web Tokens (JWTs) --> Stateless --> Doesn't require sotring data on a server

--> Both Express Session and JSON Web Tokens (JWTs) are commonly used for web authentication \
and session management, but they differ in how they store and share session data

--> Express Session is a server-side session management system built into the Express \
web framework for Node.js. It stores session data on the server and assigns each session \
a unique session ID. This session ID is then sent to the client as a cookie, and \
subsequent client requests include the session ID in a cookie header. The server uses \
this session ID to lookup and retrieve the associated session data from its storage. \
This is an example of a server-side session management system

--> JSON Web Tokens (JWTs), on the other hand, are a stateless way of transmitting \
information between parties as a JSON object. JWTs consist of a header, payload, and \
signature that are base64 encoded and concatenated with periods. They are often used in \
web authentication to transmit user data between the client and server as a compact and \
URL-safe string. Because JWTs are self-contained and contain all the necessary \
information to validate and authenticate the user, they do not require the server to \
store any session data. This is an example of a token-based authentication system

--> In summary, Express Session is a server-side session management system that uses \
a session ID stored as a cookie on the client to retrieve session data from the server, \
while JSON Web Tokens are a self-contained token-based authentication system that do not \
require storing session data on the server

+++ Basically how the Express Session works +++

--> Client sends request to Server --> Server checks cookie to get sessionID
+ Server has sessionID and it is valid --> Find that session --> Use the information in that session \
  --> set new cookie with the same sessionID with new expires property
+ Server can't find cookie or sessionID not found or expires --> Create new session and send new cookie

+++ Implementation of Passport Local Strategy +++

npm install passport
npm install passport-local

--> User model
--> create passport.js

--> Define the strategy
--> Define the verify callback of the Passport Local strategy

---
const customFields = {
  usernameField: 'uname',
  passwordField: 'pw'
};

const varifyCallback = (username, password, done) => {
  User.findOne({ username: username })
    .then(user => {
      if (!user) return done(null, false);

      const isValid = validPassword(password, user.hash, user.salt);
      
      if (isValid) return done(null, user);
      else return done(null, false);
    })
    .catch(error => done(error));
};

const startegy = new LocalStrategy(customFields, verifyCallback);

passport.use(strategy);

passport.serializeUser((user, done) => {
  done(null, user.id);
});
passport.deserializeUser((userId, done) => {
  User.findById(userId)
    .then((user) => {
      done(null, user);
    })
    .catch(error => done(error));
});
---

--> authRoute.js
--> authController.js

---
// passport.authenticate('local')
router.post('/login', passport.authenticate('local'), (req, res, next) => {});
---

--> app.js

---
// app.use(session(sessionOptions))
require('./config.passport');

app.use(passport.initialize());
--> Passport initializes its Authentication strategies
--> Mounts its middleware to request handling chain

app.use(passport.session());
--> Maintain the user's session
--> Persist the user's authenticated state across all requests
---

--> Register

---
router.post('/register', (req, res, next) => {
  const { salt, hash } = genPassword(req.body.pw);

  const newUser = new User({
    username: req.body.uname,
    hash: hash,
    salt: salt
  });

  newUser.save()
    .then((user) => {
      console.log(user);
    });

  re.redirect('/login');
});
---

---
router.post('/login', passport.authenticate('local', {
  failureRedirect: 'login-failure',
  successRedirect: 'login-success'
}));
---

+++ Passport Serialize and Deserialize Configuration +++

---
app.use((req, res, next) => {
  console.log(req.session); // created by express-session
  console.log(req.user); // created by passport

  next();
});
---

--> isAuth and isAmin

--> test req.session.cookie and req.session.passport
--> test throw error in Verify Callback

+++ Public Key Cryptography +++

--> Public Key Cryptography --> Asymmetric Cryptography
--> Asymmetric Cryptography (2 keys: Public Key and Private Key for Encrypt and Decrypt data)
--> Symmetric Cryptography (1 key)

  Public Key Cryptography, also known as asymmetric cryptography, is a cryptographic \
technique that utilizes a pair of keys, a public key and a private key, to secure \
communication over an insecure channel. The public key is used for encryption, while \
the private key is used for decryption.
  The key pair is generated by a mathematical algorithm, and the public key can be \
freely distributed and shared with others, while the private key must be kept secret. \
When someone wants to send a message to the owner of the public key, they encrypt the \
message using the public key. Only the owner of the corresponding private key can \
decrypt the message.
  This mechanism provides a secure way for two parties who have not previously \
exchanged any secret information to communicate safely, as anyone can encrypt messages \
with the public key, but only the owner of the corresponding private key can decrypt \
them. Public Key Cryptography is widely used today in various applications, such as \
secure communication over the internet, digital signatures, and secure electronic transactions.

--> Asymmetric Cryptography v/s Symmetric Cryptography

--> Asymmetric Cryptography --> Public Key Cryptography
--> Symmetric Cryptography --> Private Key Cryptography

--> A TDF --> A Trap Door Funciton
  A Trap Door Function (TDF) is a type of mathematical function that is relatively \
easy to calculate in one direction, but extremely difficult to reverse, unless a \
specific mathematical "key" or "trapdoor" is known. This key allows someone to \
efficiently reverse the function.
--> A Trap Door Function is a one-way function that takes some pretty big piece of \
data and compresses it into a deterministic small piece of data outcome
--> sha256 hash

--> Elliptic curve multiplication --> ECC --> Private Key to Public Key
--> Public Key Cryptography --> ECC --> TDF Trap Door Function
--> Private Key --> Public Key
--> Public key -x-> Private Key

--> Public Key Cryptography
1. Protect some sort of data
2. Verify an identity

--> ECC --> Elliptic Curve Cryptography
+ The basis of Public Key Cryptography
+ A Trap Door Function
+ Mathematically links the private and public keys

--> Now we know that if the Public Key corresponds to Private Key or not

--> Elliptic Curve Cryptography allows us to

--> Data Encryption
+ Encrypt(someMessage, public_key)
+ Decrypt(someMessage, private_key)

--> Identity Verification --> Digital Signatures
+ Encrypt(someMessage, private_key)
+ Decrypt(someMessage, public_key)

--> Digital Signature and Verify Identity

+++ How JWTs work? +++

--> What is JWTs --> Base64url encoded characters
--> JWTs --> Self-contained way for securely transmitting information between \
parties in a JSON objects
--> Used to authenticate and authorize users in Web and Mobile applications
+ Header --> Informations, hashing algorithm,...
+ Payload --> Claims --> User's ID,...
+ Signature
--> RS256 --> RSA + SHA256
--> RSA for Public Key and Private Key
--> SHA256 for hashing the header and the payload

--> Base64 and Base64url
--> Base64 is a binary-to-text encoding scheme that represents binary data \
in an ASCII string format. Base64url is a variant of Base64 that uses a \
modified alphabet that is URL-safe and is designed to be used in URLs and URIs

--> Server
--> Sign JWTs using Private Key
--> Verify JWTs using Public Key

--> Private Key + Hash --> Signature
--> Public Key + Signature --> Hash

+++ Implementation of Passport JWT Strategy +++

--> Most Complex
--> Use the NodeJS crypto library and write our own middleware to sign and \
verify JWTs

--> Somewhat Complex
--> Use the jsonwebtoken NPM module and write our own middleware

--> Least Complex
--> Use the jsonwebtoken NPM module and use passport-jwt as our middleware

--> The JWT Authentication Process
1. User logs in to web app, and is issued a Json Web Token (JWT)
2. User client (usually a browser like Google Chrome) stores the JTW in local storage \
or a Cookie
3. On every HTTP request that requires authentication, the user client (browser) \
will attach the JWT in the "Authorization" HTTP header
4. The server looks for the JWT in the "Authorization" HTTP header and verifies \
the signature
5. If the signature is valid, the server decodes the JWT, usually gets the \
database ID of the user in the "payload.sub" field, looks the user up in the database, \
and stores the user object to use
6. The user receives the route data

--> Cookies can be a good option for storing sensitive information like JWTs \
because they can be set with an `HttpOnly` flag that prevents them from being \
accessed or manipulated through JavaScript. This makes them more secure against \
cross-site scripting (XSS) attacks. However, cookies are also vulnerable to \
cross-site request forgery (CSRF) attacks, where a malicious website could trick \
a user into making an unintended request to the target website. To prevent CSRF \
attacks, the cookie should also be set with a `SameSite=Strict` attribute, which \
ensures that the cookie is only sent in first-party contexts

+++ Code +++

--> app.use(passport.initialize());
--> JWT Implementation --> Don't need app.use(passport.session())

passportJTWOptions = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: PUB_KEY || secret phrase,
  issuer: "enter issuer here",
  audience: "enter audience here",
  algorithms: ["RS256"],
  ignoreExpiration: false,
  passReqToCallback: false,
  jsonwebtokenOptions: {
    complete: false,
    clockTolerance: "",
    maxAge: "2d",
    clockTimestamp: "100",
    nonce: "string here for OpenID"
  }
}

---
const { JwtStrategy, ExtractJwt } = require("passport-jwt");
---